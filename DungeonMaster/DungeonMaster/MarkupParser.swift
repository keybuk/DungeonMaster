//
//  MarkupParser.swift
//  DungeonMaster
//
//  Created by Scott James Remnant on 12/27/15.
//  Copyright © 2015 Scott James Remnant. All rights reserved.
//

import UIKit

/// MarkupParserFeature represents the markup features that can be parsed by calls to `parseText`.
struct MarkupParserFeatures : OptionSet {
    let rawValue: UInt
    static let None = MarkupParserFeatures(rawValue: 0)
    static let Emphasis = MarkupParserFeatures(rawValue: 1)
    static let Links = MarkupParserFeatures(rawValue: 1 << 1)
    static let Quotes = MarkupParserFeatures(rawValue: 1 << 2)
    static let Apostrophes = MarkupParserFeatures(rawValue: 1 << 3)
    
    static let All: MarkupParserFeatures = [ .Emphasis, .Links, .Quotes, .Apostrophes ]
}

/// MarkupParser parses the markup format used by rules, and monster and spell lists into an `NSAttributedString` for display.
///
/// The markup format is extremely lightweight, and is similar to Markdown in someways.
///
/// The following inline markup is recognized in paragraphs and bulleted lists:
/// - \*text\* is output emphasised in *italics*.
/// - \*\*text\*\* is output emphasised in **bold**.
/// - \*\*\*text\*\*\* is output in a ***bold and italics***.
/// - [text] is recognized as a link to another monster or spell named "text".
/// - [text](alternate text) is also recognized as a link to "text", but displayed as "alternate text".
/// - "text" (double quotes) is rendered with smart quotes as “text”.
/// - single quotes in words like "can't" are also rendered with smart quotes as "can’t".
///
/// Headings can be created by beginning the line with "# ", e.g.:
///
///     # This is a heading
///
/// Paragraphs with an alternate indentation style can be created by beginning the lines with "} ", e.g.:
///
///     } **Title.** All but the first line will be indented.
///     } **Title.** Next paragraph has no first-line indent.
///
/// Bulleted lists can be created by beginning the line with "• ", e.g.:
///
///     • Bullet item.
///     • Second bullet item.
///
/// Tables can be constructed using "|" as the column separator, e.g.:
///
///     d100 | Result
///     00–49 | Nothing happens
///     50–99 | Something happens
///
/// Columns with numeric data are center-aligned, while other data is left-aligned.
class MarkupParser {
    
    /// Links in the text have the following attribute set to the link name.
    ///
    /// You can obtain the target of links, and their locations, using `markupParser.text.attribute(markupParser.linkAttributeName, atIndex: ..., effectiveRange: ...)`
    static let linkAttributeName = "DungeonMaster.MarkupParser.LinkAttribute"
    
    /// Paragraph indent used on following paragraphs, and in bulleted lists.
    var paragraphIndent: CGFloat = 20.0
    
    /// Spacing between paragraphs, bulleted lists, and tables.
    var paragraphSpacing: CGFloat = 10.0
    
    /// Spacing before the first item generated by the parser.
    var paragraphSpacingBefore: CGFloat = 0.0
    
    /// Width to render tables.
    ///
    /// Tables are ordinarily set to be rendered only as wide as is necessary for the data within. By setting this value, non-numeric table columns will be proportionally stretched to fill the entire width.
    var tableWidth: CGFloat?
 
    /// Spacing between table columns.
    var tableSpacing: CGFloat = 10.0
    
    /// Color to apply to links.
    var linkColor: UIColor?
    
    /// Parsed text.
    var text: NSAttributedString {
        return mutableText
    }

    private let whitespace: CharacterSet
    
    private let bodyFontDescriptor: UIFontDescriptor
    private let tableFontDescriptor: UIFontDescriptor
    private let tableHeadingFontDescriptor: UIFontDescriptor
    private let headingFontDescriptor: UIFontDescriptor

    private let emphasisedTraits: [UIFontDescriptorSymbolicTraits]
    
    private var lastBlock: LastBlock
    private var mutableText: NSMutableAttributedString

    init() {
        whitespace = CharacterSet.whitespaces
        
        bodyFontDescriptor = UIFontDescriptor.preferredFontDescriptor(withTextStyle: UIFontTextStyle.body)
        tableFontDescriptor = bodyFontDescriptor.withSize(floor(bodyFontDescriptor.pointSize * 0.9))
        tableHeadingFontDescriptor = tableFontDescriptor.withSymbolicTraits(.traitBold)!
        headingFontDescriptor = UIFontDescriptor.preferredFontDescriptor(withTextStyle: UIFontTextStyle.headline)
        
        emphasisedTraits = [
            [],
            .traitItalic,
            .traitBold,
            [ .traitBold, .traitItalic ]
        ]
        
        lastBlock = LastBlock.none
        mutableText = NSMutableAttributedString()
    }
    
    enum LastBlock {
        case none
        case table(Int, Int, [CGFloat], [NSTextAlignment])
        case finishedTable
        case bullet
        case heading
        case indentParagraph
        case paragraph
        case lineBreak
    }
    
    /// Parse lines of text.
    ///
    /// Each line is treated as a complete paragraph, bulleted list item, or table row, and a newline automatically appended to the attributed stirng.
    ///
    /// Multiple calls to `parse` extend the attributed string.
    func parse(_ lines: [String]) {
        for line in lines {
            if line.contains("|") {
                parse(tableLine: line)
            } else {
                layoutTableIfNeeded()
                if line.hasPrefix("•") {
                    parse(bulletLine: line)
                } else if line.hasPrefix("#") {
                    parse(headingLine: line)
                } else if line.hasPrefix("}") {
                    parse(indentLine: line)
                } else if line != "" {
                    parse(textLine :line)
                } else {
                    lastBlock = .lineBreak
                }
            }
        }
        
        layoutTableIfNeeded()
    }
    
    /// Parse a block of text.
    ///
    /// The line begins a new complete paragraph, bulleted list item, or table row. Embedded newlines in the text result in the next line also being considered as a new complete paragraph, bulleted list item, or table row. A newline is automatically appended to the attributed string.
    ///
    /// Multiple calls to `parse` extend the attributed string.
    func parse(_ line: String) {
        parse(line.components(separatedBy: "\n"))
    }
    
    /// Reset the parser.
    ///
    /// After this call, the attribtued string is empty, and the parser treats a new call to `parse` as beginning new markup.
    func reset() {
        lastBlock = LastBlock.none
        mutableText = NSMutableAttributedString()
    }
    
    private func parse(tableLine line: String) {
        // Tables are rendered as a series of tabbed data.
        let paragraphStyle = NSMutableParagraphStyle()
        paragraphStyle.lineBreakMode = .byClipping
        paragraphStyle.tabStops = []
        paragraphStyle.lineHeightMultiple = CGFloat(1/0.9 * 1.2)
        paragraphStyle.lineSpacing = tableFontDescriptor.pointSize * 0.5
        
        switch lastBlock {
        case .table(_, _, _, _), .heading:
            break
        case .none:
            paragraphStyle.paragraphSpacingBefore = paragraphSpacingBefore
        default:
            paragraphStyle.paragraphSpacingBefore = paragraphSpacing
        }
        
        // Build up the table row-per-row.
        let font: UIFont
        var tableIndex = mutableText.length
        var tableRows = 0
        var tableWidths: [CGFloat] = []
        var tableAlignments: [NSTextAlignment] = []
        
        if case let .table(index, rows, widths, alignments) = lastBlock {
            tableIndex = index
            tableRows = rows
            tableWidths = widths
            tableAlignments = alignments

            // Body rows use the standard font.
            font = UIFont(descriptor: tableFontDescriptor, size: 0.0)
        } else {
            // First row always has its font set to the heading font.
            font = UIFont(descriptor: tableHeadingFontDescriptor, size: 0.0)
        }
        
        // Get sexy with the coloring.
        var attributes: [String: Any] = [
            NSFontAttributeName: font,
            NSParagraphStyleAttributeName: paragraphStyle,
        ]
        if tableRows % 2 == 1 {
            attributes[NSBackgroundColorAttributeName] = UIColor(white: 0.0, alpha: 0.05)
        }

        // Split the line into columns, and calculate the render widths and alignment.
        var columns: [NSAttributedString] = []
        for (index, column) in line.components(separatedBy: "|").enumerated() {
            let column = parseText(column.trimmingCharacters(in: whitespace), attributes: attributes, features: .All, appendNewline: false)
            
            // Calculate the column width, and save if it's larger than the previous width.
            var width = ceil(column.size().width)
            if index < tableWidths.count {
                width = max(width, tableWidths[index])
                tableWidths[index] = width
            } else {
                tableWidths.append(width)
            }
            
            // Figure out the alignment, and revert to .Left if .Center wouldn't apply to any one row.
            var alignment = tableRows == 0 ? .center : self.alignment(forColumn: column.string)
            if index < tableAlignments.count {
                alignment = alignment == tableAlignments[index] ? alignment : .left
                tableAlignments[index] = alignment
            } else {
                tableAlignments.append(alignment)
            }
            
            columns.append(column)
        }
        
        // Append the new row.
        for column in columns {
            mutableText.append(NSAttributedString(string: "\t", attributes: attributes))
            mutableText.append(column)
        }
        mutableText.append(NSAttributedString(string: "\n", attributes: attributes))

        lastBlock = .table(tableIndex, tableRows + 1, tableWidths, tableAlignments)
    }
    
    private func alignment(forColumn column: String) -> NSTextAlignment {
        for character in column.characters {
            switch character {
            case "0"..."9", "+", "-", "–", "—":
                continue
            default:
                return .left
            }
        }
        
        return .center
    }

    private func layoutTableIfNeeded() {
        guard case let .table(tableIndex, _, tableWidths, tableAlignments) = lastBlock else { return }
        
        // Calculate the combined column widths, and find the widest column.
        var flexibleColumnWidths: CGFloat = 0.0, fixedColumnWidths: CGFloat = 0.0
        var widestColumnWidth: CGFloat?, widestColumnIndex: Int?
        for (index, (alignment, width)) in zip(tableAlignments, tableWidths).enumerated() {
            if alignment == .left {
                flexibleColumnWidths += width
                if width > (widestColumnWidth ?? 0.0) {
                    widestColumnWidth = width
                    widestColumnIndex = index
                }
            } else {
                fixedColumnWidths += width
            }
        }
        
        // If the parser has a fixed table width set, calculate how much space is available for the flexible columns. This dictates either how much we can expand the columns (when undersized), or how much we would need to shrink the widest column (when oversized).
        var availableColumnWidths: CGFloat?
        if let tableWidth = tableWidth {
            availableColumnWidths = (tableWidth - CGFloat(tableWidths.count + 1) * tableSpacing - fixedColumnWidths)
        }

        // Lay out the tab stops at the appropriate places for the columns.
        var location = tableSpacing
        var tabStops: [NSTextTab] = []
        for (index, (alignment, width)) in zip(tableAlignments, tableWidths).enumerated() {
            var width = width, columnLocation = location
            if alignment == .center {
                columnLocation += width / 2.0
            } else if let availableColumnWidths = availableColumnWidths {
                if flexibleColumnWidths < availableColumnWidths {
                    // Table needs expanding, scale the column up proportionally.
                    width = round(width / flexibleColumnWidths * availableColumnWidths)
                } else if let widestColumnIndex = widestColumnIndex, flexibleColumnWidths > availableColumnWidths && (flexibleColumnWidths - width) <= availableColumnWidths && index == widestColumnIndex {
                    // Table needs collapsing, this is the widest column, and removing it would get us under again.
                    width = availableColumnWidths - (flexibleColumnWidths - width)
                    
                    collapseTableColumn(index, to: width)
                }
            }
            
            tabStops.append(NSTextTab(textAlignment: alignment, location: columnLocation, options: [String:AnyObject]()))
            location += width + tableSpacing
        }
        
        // Apply the tab stops to the table by updating the previous paragraph styles
        var index = tableIndex
        while index < mutableText.length {
            var range = NSRange()
            if let priorStyle = mutableText.attribute(NSParagraphStyleAttributeName, at: index, effectiveRange: &range) as? NSParagraphStyle {
                let paragraphStyle = NSMutableParagraphStyle()
                paragraphStyle.setParagraphStyle(priorStyle)
                paragraphStyle.tabStops = tabStops
                
                mutableText.addAttribute(NSParagraphStyleAttributeName, value: paragraphStyle, range: range)
            }
            
            index = range.location + range.length
        }
        
        // Since the table has been laid out, we can't extend it any further. Make sure that the next parse() call starts a new table if it has one.
        lastBlock = .finishedTable
    }
    
    private func collapseTableColumn(_ columnIndex: Int, to width: CGFloat) {
        guard case let .table(tableIndex, _, _, _) = lastBlock else { return }
        let delimiterCharacterSet = CharacterSet(charactersIn: "\t\n")
        
        var column: Int?
        var fragment: NSAttributedString?
        var fragments: [NSAttributedString] = []
        var fragmentWidth: CGFloat?
        var fragmentWidths: [CGFloat] = []
        var savedTrailing: NSAttributedString?

        // What's going on here:
        // We have to do the reflowing based on the NSAttributedStrings in the table, including preserving all of the formatting, so fragments are built by extracting and appending those attributed strings, and when we replace in the text, we also use those. For these we have to make NSRange() to pass in as arguments.
        // But we need to use Swift's String's rangeOfCharacterFromSet() and enumerateSubstringsInRange() to do the breaking up and reflowing of the text. These give us Range<Index> instead.
        // So we start with String and Range<Index>, we make an NSRange() to get an NSAttributedString ... and after futzing we have to update the Index again by re-generating it to avoid errors because we went past what the endIndex would have been before the futz.
        var index = mutableText.string.characters.index(mutableText.string.startIndex, offsetBy: tableIndex)
        while index != mutableText.string.endIndex {
            guard let delimiterIndexRange = mutableText.string.rangeOfCharacter(from: delimiterCharacterSet, options: [], range: index..<mutableText.string.endIndex) else { break }

            if let column = column, column == columnIndex {
                // Generate string fragments to fit within width.
                mutableText.string.enumerateSubstrings(in: index..<delimiterIndexRange.lowerBound, options: .byWords) { (substring, substringRange, enclosingRange, stop: inout Bool) in
                    let range = NSRange(location: self.mutableText.string.characters.distance(from: self.mutableText.string.startIndex, to: substringRange.lowerBound), length: self.mutableText.string.characters.distance(from: substringRange.lowerBound, to: substringRange.upperBound))
                    let subtext = self.mutableText.attributedSubstring(from: range)

                    let newFragment = NSMutableAttributedString(attributedString: fragment ?? NSAttributedString())
                    if let savedTrailing = savedTrailing {
                        newFragment.append(savedTrailing)
                    }
                    newFragment.append(subtext)
                    
                    let newWidth = ceil(newFragment.size().width)
                    if newWidth > width {
                        if let fragment = fragment, let fragmentWidth = fragmentWidth {
                            fragments.append(fragment)
                            fragmentWidths.append(fragmentWidth)
                        }
                        fragment = subtext
                        fragmentWidth = ceil(subtext.size().width)
                    } else {
                        fragment = newFragment
                        fragmentWidth = newWidth
                    }

                    let trailingRange = NSRange(location: self.mutableText.string.characters.distance(from: self.mutableText.string.startIndex, to: substringRange.upperBound), length: self.mutableText.string.characters.distance(from: substringRange.upperBound, to: enclosingRange.upperBound))
                    savedTrailing = self.mutableText.attributedSubstring(from: trailingRange)
                }

                if let fragment = fragment, let fragmentWidth = fragmentWidth {
                    fragments.append(fragment)
                    fragmentWidths.append(fragmentWidth)
                }
                
                // Replace the text in the column with the first fragment.
                let fragment = fragments.removeFirst()
                let range = NSRange(location: mutableText.string.characters.distance(from: mutableText.string.startIndex, to: index), length: mutableText.string.characters.distance(from: index, to: delimiterIndexRange.lowerBound))
                mutableText.replaceCharacters(in: range, with: fragment)
                
                // Since we've mutated the string, `index(_, offsetBy: fragment.length)` would do the wrong thing and check against its previous notion of what the length of the string was. Thus recalculate index against the string, using the previously saved `location`.
                index = mutableText.string.characters.index(mutableText.string.startIndex, offsetBy: range.location + fragment.length)
            } else {
                // No mutation has occurred, we can just point at the delimiter directly.
                index = delimiterIndexRange.lowerBound
            }
            
            // Index now points at the delimiter, whether the string was mutated or not. `delimiterIndexRange` might not, but it's length is still valid.
            let delimiterRange = NSRange(location: mutableText.string.characters.distance(from: mutableText.string.startIndex, to: index), length: mutableText.string.characters.distance(from: delimiterIndexRange.lowerBound, to: delimiterIndexRange.upperBound))
            let delimiter = mutableText.attributedSubstring(from: delimiterRange)
            if delimiter.string == "\n" {
                if fragments.count > 0 {
                    // Replace the delimiter with itself, followed by a line for each of the fragments prefixed with the right numbers of indents.
                    let following = NSMutableAttributedString(attributedString: delimiter)
                    let attributes = following.attributes(at: 0, effectiveRange: nil)
                    
                    let prefix: String = Array(repeating: "\t", count: columnIndex + 1).joined(separator: "")
                    for fragment in fragments {
                        following.append(NSAttributedString(string: prefix, attributes: attributes))
                        following.append(fragment)
                        following.append(NSAttributedString(string: "\n", attributes: attributes))
                    }

                    mutableText.replaceCharacters(in: delimiterRange, with: following)
                    
                    // Since we've mutated the string, the index has to be recalculated once more; again this is easy because we know the range where we inserted characters and what we replaced, and that included the delimiter. So we just point past our insertion.
                    index = mutableText.string.characters.index(mutableText.string.startIndex, offsetBy: delimiterRange.location + following.length)
                } else {
                    // Point past the delimiter by advancing the index.
                    index = mutableText.string.characters.index(index, offsetBy: delimiterRange.length)
                }
                
                column = nil
                fragment = nil
                fragments.removeAll()
                fragmentWidth = nil
                fragmentWidths.removeAll()
                savedTrailing = nil
            } else {
                column = column != nil ? column! + 1 : 0
                // Point past the delimiter by advancing the index.
                index = mutableText.string.characters.index(index, offsetBy: delimiterRange.length)
            }
        }
    }
    
    private func parse(bulletLine line: String) {
        // Bulleted list are rendered as paragraph blocks with special intents.
        let line = line.substring(from: line.characters.index(line.startIndex, offsetBy: 1))
        
        // If the bullet list follows a paragraph, preceed it with paragraph spacing.
        let paragraphStyle = NSMutableParagraphStyle()
        switch lastBlock {
        case .bullet, .heading:
            break
        case .none:
            paragraphStyle.paragraphSpacingBefore = paragraphSpacingBefore
        default:
            paragraphStyle.paragraphSpacingBefore = paragraphSpacing
        }
        
        paragraphStyle.headIndent = paragraphIndent
        paragraphStyle.tabStops = [
            NSTextTab(textAlignment: .left, location: paragraphIndent, options: [String: AnyObject]())
        ]

        let attributes: [String: Any] = [
            NSFontAttributeName: UIFont(descriptor: bodyFontDescriptor, size: 0.0),
            NSParagraphStyleAttributeName: paragraphStyle
        ]

        // Append the bullet and a tab stop to move the following text to the right point.
        mutableText.append(NSAttributedString(string: "•\t", attributes: attributes))
        mutableText.append(parseText(line, attributes: attributes, features: .All, appendNewline: true))
        
        lastBlock = .bullet
    }
    
    private func parse(headingLine line: String) {
        // Improved font.
        let line = line.substring(from: line.characters.index(line.startIndex, offsetBy: 1)).trimmingCharacters(in: whitespace)

        let paragraphStyle = NSMutableParagraphStyle()
        switch lastBlock {
        case .none:
            paragraphStyle.paragraphSpacingBefore = paragraphSpacingBefore
        default:
            paragraphStyle.paragraphSpacingBefore = paragraphSpacing
        }

        let attributes: [String: Any] = [
            NSFontAttributeName: UIFont(descriptor: headingFontDescriptor, size: 0.0),
            NSParagraphStyleAttributeName: paragraphStyle,
        ]

        mutableText.append(parseText(line, attributes: attributes, features: .All, appendNewline: true))
        
        lastBlock = .heading
    }
    
    private func parse(indentLine line: String) {
        // This differs from a standard paragraph only in style.
        let line = line.substring(from: line.characters.index(line.startIndex, offsetBy: 1)).trimmingCharacters(in: whitespace)

        let paragraphStyle = NSMutableParagraphStyle()
        switch lastBlock {
        case .indentParagraph, .heading:
            break
        case .none:
            paragraphStyle.paragraphSpacingBefore = paragraphSpacingBefore
        default:
            paragraphStyle.paragraphSpacingBefore = paragraphSpacing
        }
        
        paragraphStyle.headIndent = paragraphIndent
        
        let attributes = [
            NSFontAttributeName: UIFont(descriptor: bodyFontDescriptor, size: 0.0),
            NSParagraphStyleAttributeName: paragraphStyle
        ]
        
        mutableText.append(parseText(line, attributes: attributes, features: .All, appendNewline: true))
        
        lastBlock = .indentParagraph
    }
    
    private func parse(textLine line: String) {
        // Indent all except the first paragraphs in a block.
        let paragraphStyle = NSMutableParagraphStyle()
        switch lastBlock {
        case .heading:
            break
        case .paragraph:
            paragraphStyle.firstLineHeadIndent = paragraphIndent
        case .none:
            paragraphStyle.paragraphSpacingBefore = paragraphSpacingBefore
        default:
            paragraphStyle.paragraphSpacingBefore = paragraphSpacing
        }
        
        let attributes = [
            NSFontAttributeName: UIFont(descriptor: bodyFontDescriptor, size: 0.0),
            NSParagraphStyleAttributeName: paragraphStyle
        ]
        
        mutableText.append(parseText(line, attributes: attributes, features: .All, appendNewline: true))
        
        lastBlock = .paragraph
    }

    /// Parse a section of text and return as an attributed string.
    ///
    /// Unlike the `parse` function, this only handles inline attributes specified in `features`, and does not modify the `text` member of the parser.
    ///
    /// - parameter line: the text to parse.
    /// - parameter attributes: attributes to apply to the resulting `NSAttributedString`.
    /// - parameter features: parser features to enable in the string.
    /// - parameter appendNewline: whether a newline should be appended to the returned string.
    ///
    /// - returns: NSAttributedString resulting from parsing `line`.
    func parseText(_ line: String, attributes: [String: Any], features: MarkupParserFeatures, appendNewline: Bool) -> NSAttributedString {
        let line = line.trimmingCharacters(in: whitespace)
        var range = line.startIndex..<line.endIndex

        var operatorString = ""
        if features.contains(.Emphasis) {
            operatorString += "*"
        }
        if features.contains(.Links) {
            operatorString += "["
        }
        if features.contains(.Quotes) {
            operatorString += "\""
        }
        if features.contains(.Apostrophes) {
            operatorString += "'"
        }
        let operators = CharacterSet(charactersIn: operatorString)

        
        let text = NSMutableAttributedString()
        loop: while true {
            if let operatorRange = line.rangeOfCharacter(from: operators, options: [], range: range) {
                // Might be an initial piece of text before the first operator in the line.
                if range.lowerBound != operatorRange.lowerBound {
                    let string = line.substring(with: range.lowerBound..<operatorRange.lowerBound)
                    text.append(NSAttributedString(string: string, attributes: attributes))
                }
                
                switch line[operatorRange.lowerBound] {
                case "*":
                    // Increased numbers of * indicate increased emphasis.
                    var index = operatorRange.lowerBound
                    while index != range.upperBound && line[index] == "*" {
                        index = line.index(index, offsetBy: 1)
                    }
                    
                    // Locate the end of the emphasised range.
                    if let endOperatorRange = line.range(of: "*", options: [], range: index..<range.upperBound, locale: nil) {
                        // Find the end of the end operator.
                        var endIndex = endOperatorRange.lowerBound
                        while endIndex != range.upperBound && line[endIndex] == "*" {
                            endIndex = line.index(endIndex, offsetBy: 1)
                        }

                        // If the start operator is too long, treat it as initial *s followed by the right operator.
                        var emphasisness = line.distance(from: operatorRange.lowerBound, to: index)
                        if emphasisness > emphasisedTraits.count || emphasisness > line.distance(from: endOperatorRange.lowerBound, to: endIndex) {
                            emphasisness = min(emphasisedTraits.count, line.distance(from: endOperatorRange.lowerBound, to: endIndex))
                            
                            let overlength = line.distance(from: operatorRange.lowerBound, to: index) - emphasisness
                            let string = line.substring(with: operatorRange.lowerBound..<line.index(operatorRange.lowerBound, offsetBy: overlength))
                            text.append(NSAttributedString(string: string, attributes: attributes))
                        }
                        
                        // Emphasised text. We special-case the situation where the entire line is emphasised, and include the newline in the emphasis.
                        var string = line.substring(with: index..<endOperatorRange.lowerBound)
                        if appendNewline && operatorRange.lowerBound == line.startIndex && endIndex == line.endIndex {
                            string += "\n"
                        }
                        
                        let fontDescriptor = (attributes[NSFontAttributeName] as? UIFont)?.fontDescriptor ?? bodyFontDescriptor
                        
                        var emphasisAttributes = attributes
                        if let emphasisedFontDescriptor = fontDescriptor.withSymbolicTraits(emphasisedTraits[emphasisness]) {
                            emphasisAttributes[NSFontAttributeName] = UIFont(descriptor: emphasisedFontDescriptor, size: 0.0)
                        }
                        
                        text.append(parseText(string, attributes: emphasisAttributes, features: features, appendNewline: false))
                        
                        // If the end operator is too long, treat it as the right operator followed by *s.
                        if line.distance(from: endOperatorRange.lowerBound, to: endIndex) > emphasisness {
                            let overlength = line.distance(from: endOperatorRange.lowerBound, to: endIndex) - emphasisness
                            let string = line.substring(with: line.index(endOperatorRange.lowerBound, offsetBy: overlength)..<endIndex)
                            text.append(NSAttributedString(string: string, attributes: attributes))
                        }

                        range = endIndex..<range.upperBound
                        
                        // Don't double-add a newline.
                        if string.hasSuffix("\n") {
                            break loop
                        }
                        
                    } else {
                        // Didn't find the end emphasis; add the entire emphasis operator range to the output and continue from after it.
                        text.append(NSAttributedString(string: line.substring(with: operatorRange.lowerBound..<index), attributes: attributes))
                        
                        range = index..<range.upperBound
                    }
                case "[":
                    // Locate the end of the link.
                    if let endOperatorRange = line.range(of: "]", options: [], range: operatorRange.upperBound..<range.upperBound, locale: nil) {
                        let linkName = line.substring(with: operatorRange.upperBound..<endOperatorRange.lowerBound)
                        var linkText = linkName
                        
                        range = endOperatorRange.upperBound..<range.upperBound

                        // The link can optionally be immediately followed by an alternate text to add.
                        if line.substring(from: endOperatorRange.upperBound).hasPrefix("(") {
                            if let endAlternateRange = line.range(of: ")", options: [], range:endOperatorRange.upperBound..<range.upperBound, locale: nil) {
                                linkText = line.substring(with: line.index(endOperatorRange.upperBound, offsetBy: 1)..<endAlternateRange.lowerBound)
                                range = endAlternateRange.upperBound..<range.upperBound
                            }
                        }
                        
                        var linkAttributes = attributes
                        linkAttributes[MarkupParser.linkAttributeName] = linkName
                        if let linkColor = linkColor {
                            linkAttributes[NSForegroundColorAttributeName] = linkColor
                        }
                        
                        // Add the text in the link to the output.
                        text.append(parseText(linkText, attributes: linkAttributes, features: features, appendNewline: false))
                        
                    } else {
                        // Didn't find an end to the link; just add the start operator to the output.
                        text.append(NSAttributedString(string: line.substring(with: operatorRange), attributes: attributes))
                        
                        range = operatorRange.upperBound..<range.upperBound
                    }
                case "\"":
                    // Locate the end of the quoted string.
                    if let endOperatorRange = line.range(of: "\"", options: [], range: operatorRange.upperBound..<range.upperBound, locale: nil) {
                        // Replace the quotes with smart quotes.
                        let string = "“\(line.substring(with: operatorRange.upperBound..<endOperatorRange.lowerBound))”"
                        text.append(parseText(string, attributes: attributes, features: features, appendNewline: false))

                        range = endOperatorRange.upperBound..<range.upperBound
                    } else {
                        // Didn't find an end to the quote; just add the start quote to the output as a non-smart quote.
                        text.append(NSAttributedString(string: line.substring(with: operatorRange), attributes: attributes))
                        
                        range = operatorRange.upperBound..<range.upperBound
                    }
                case "'":
                    // No end operator here, just add the replacement quote to the string.
                    text.append(NSAttributedString(string: "’", attributes: attributes))
                    
                    range = operatorRange.upperBound..<range.upperBound
                default:
                    abort()
                }
                
            } else {
                // Remaining part of line after last operator, or entire line when there is no operator.
                var trailing = line.substring(with: range)
                if appendNewline {
                   trailing += "\n"
                }
                
                if trailing != "" {
                    text.append(NSAttributedString(string: trailing, attributes: attributes))
                }
                
                break loop
            }
        }
        
        return text
    }
    
}
