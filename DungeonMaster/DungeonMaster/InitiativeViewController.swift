//
//  InitiativeViewController.swift
//  DungeonMaster
//
//  Created by Scott James Remnant on 2/4/16.
//  Copyright Â© 2016 Scott James Remnant. All rights reserved.
//

import CoreData
import UIKit

class InitiativeViewController : UITableViewController, NSFetchedResultsControllerDelegate {
    
    var encounter: Encounter!
    var game: Game!

    @IBOutlet var doneButtonItem: UIBarButtonItem!
    
    var nextTurnOnDone = false

    override func viewDidLoad() {
        super.viewDidLoad()
        
        // When this is the first initiative roll, we use it to indicate that the game is to be begun.
        if encounter.round == 0 {
            encounter.addPlayers(fromGame: game)
            encounter.round = 1
            nextTurnOnDone = true
        }
        
        // Roll initiative for any monster without it.
        if encounter.rollInitiative() {
            PlaySound(.Initiative)
        }
        
        // Always in editing mode.
        setEditing(true, animated: false)
        validateEncounter()
    }
    
    func validateEncounter() {
        for case let combatant as Combatant in encounter.combatants {
            if combatant.initiative == nil {
                doneButtonItem.isEnabled = false
                return
            }
        }
        
        doneButtonItem.isEnabled = true
    }
    
    // MARK: Actions
    
    @IBAction func doneButtonTapped(_ sender: UIBarButtonItem) {
        if nextTurnOnDone {
            encounter.nextTurn()
        }
        
        encounter.lastModified = Date()
        try! managedObjectContext.save()

        dismiss(animated: true, completion: nil)
    }
    
    
    // MARK: Fetched results controller
    
    lazy var fetchedResultsController: NSFetchedResultsController = { [unowned self] -> <<error type>> in
        let fetchRequest = self.encounter.fetchRequestForCombatants()
        
        let fetchedResultsController = NSFetchedResultsController(fetchRequest: fetchRequest, managedObjectContext: managedObjectContext, sectionNameKeyPath: nil, cacheName: nil)
        fetchedResultsController.delegate = self
        
        try! fetchedResultsController.performFetch()
        
        return fetchedResultsController
    }()
    
    /// The set of Players that are not participating in this encounter.
    ///
    /// This is generated by using the standard results controller, and has to be reset whenever that changes.
    var missingPlayers: [Player]! {
        get {
            if let missingPlayers = _missingPlayers {
                return missingPlayers
            }
            
            // Ideally we'd use something like "NONE combatants.encounter == %@" here, but that doesn't work.
            let fetchRequest = NSFetchRequest<NSFetchRequestResult>(entity: Model.Player)
            let players = fetchedResultsController.fetchedObjects!.flatMap({ ($0 as! Combatant).player })
            fetchRequest.predicate = NSPredicate(format: "ANY playedGames.game == %@ AND NOT SELF IN %@", game, players)

            let nameSortDescriptor = NSSortDescriptor(key: "name", ascending: true)
            fetchRequest.sortDescriptors = [nameSortDescriptor]
            
            _missingPlayers = try! managedObjectContext.fetch(fetchRequest) as! [Player]
            return _missingPlayers!
        }
        
        set(newMissingPlayers) {
            _missingPlayers = newMissingPlayers
        }
    }
    fileprivate var _missingPlayers: [Player]?
    
    // MARK: UITableViewDataSource

    override func numberOfSections(in tableView: UITableView) -> Int {
        return (fetchedResultsController.sections?.count ?? 0) + 1
    }

    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        let addSection = fetchedResultsController.sections?.count ?? 0
        if section < addSection {
            let sectionInfo = fetchedResultsController.sections![section]
            return sectionInfo.numberOfObjects
        } else {
            return missingPlayers.count
        }
    }

    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let addSection = fetchedResultsController.sections?.count ?? 0
        if (indexPath as NSIndexPath).section < addSection {
            // Combatant in the encounter.
            let cell = tableView.dequeueReusableCell(withIdentifier: "InitiativeCombatantCell", for: indexPath) as! InitiativeCombatantCell
            let combatant = fetchedResultsController.object(at: indexPath) as! Combatant
            cell.combatant = combatant
            return cell
        } else {
            // Player not in the encounter.
            let cell = tableView.dequeueReusableCell(withIdentifier: "InitiativeMissingPlayerCell", for: indexPath) as! InitiativeMissingPlayerCell
            let player = missingPlayers[(indexPath as NSIndexPath).row]
            cell.player = player
            return cell
        }
        
    }

    // MARK: Edit support
    
    override func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -> Bool {
        return true
    }

    override func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) {
        if editingStyle == .delete {
            let combatant = fetchedResultsController.object(at: indexPath) as! Combatant
            managedObjectContext.delete(combatant)
        } else if editingStyle == .insert {
            let player = missingPlayers[(indexPath as NSIndexPath).row]
            let _ = Combatant(encounter: encounter, player: player, insertInto: managedObjectContext)
        }
        
        encounter.lastModified = Date()
        try! managedObjectContext.save()
    }
    
    // MARK: Move support
    
    override func tableView(_ tableView: UITableView, canMoveRowAt indexPath: IndexPath) -> Bool {
        let addSection = fetchedResultsController.sections?.count ?? 0
        if (indexPath as NSIndexPath).section < addSection {
            let combatant = fetchedResultsController.object(at: indexPath) as! Combatant
            return combatant.initiative != nil
        } else {
            return false
        }
    }
    
    var changeIsUserDriven = false
    
    override func tableView(_ tableView: UITableView, moveRowAt fromIndexPath: IndexPath, to toIndexPath: IndexPath) {
        let combatant = fetchedResultsController.object(at: fromIndexPath) as! Combatant
        let displacedCombatant = fetchedResultsController.object(at: toIndexPath) as! Combatant

        combatant.initiativeOrder = displacedCombatant.initiativeOrder! + 1
    
        var startRow = (toIndexPath as NSIndexPath).row
        if (fromIndexPath as NSIndexPath).row < (toIndexPath as NSIndexPath).row {
            startRow += 1
        }
        
        for row in startRow..<fetchedResultsController.sections![(toIndexPath as NSIndexPath).section].numberOfObjects {
            let indexPath = IndexPath(row: row, section: (toIndexPath as NSIndexPath).section)
            let adjustCombatant = fetchedResultsController.object(at: indexPath) as! Combatant
            
            // Only adjust combatants with the same initiative value, and skip the combatant we're moving!
            guard adjustCombatant.initiative == combatant.initiative else { break }
            guard adjustCombatant != combatant else { continue }
            
            adjustCombatant.initiativeOrder = adjustCombatant.initiativeOrder! + 2
        }
        
        changeIsUserDriven = true
        
        encounter.lastModified = Date()
        try! managedObjectContext.save()
    }
    
    // MARK: UITableViewDelegate
    
    override func tableView(_ tableView: UITableView, editingStyleForRowAt indexPath: IndexPath) -> UITableViewCellEditingStyle {
        let addSection = fetchedResultsController.sections?.count ?? 0
        if (indexPath as NSIndexPath).section < addSection {
            let combatant = fetchedResultsController.object(at: indexPath) as! Combatant
            return combatant.player != nil ? .delete : .none
        } else {
            return .insert
        }
    }

    override func tableView(_ tableView: UITableView, targetIndexPathForMoveFromRowAt sourceIndexPath: IndexPath, toProposedIndexPath proposedDestinationIndexPath: IndexPath) -> IndexPath {
        let combatant = fetchedResultsController.object(at: sourceIndexPath) as! Combatant
        let appendRow = fetchedResultsController.sections![0].numberOfObjects

        // First make sure we're not trying to move into the "missing players" section, and adjust the destination to the end of the combatants section if that's the case.
        var indexPath = proposedDestinationIndexPath
        if (indexPath as NSIndexPath).section != 0 || (indexPath as NSIndexPath).row == appendRow {
            indexPath = IndexPath(row: appendRow - 1, section: 0)
        }
        
        // It's okay to move to an index path that's occupied by a combatant with the same initiative.
        let displacedCombatant = fetchedResultsController.object(at: indexPath) as! Combatant
        if combatant.initiative == displacedCombatant.initiative {
            return indexPath
        } else {
            return sourceIndexPath
        }
    }
    
    // MARK: NSFetchedResultsControllerDelegate
    
    var oldMissingPlayers: [Player]?
    var selectIndexPath: IndexPath?
    
    func controllerWillChangeContent(_ controller: NSFetchedResultsController<NSFetchRequestResult>) {
        guard !changeIsUserDriven else { return }

        // Clear or reset the cache of missing players, keeping the old cache around for insertion checking.
        oldMissingPlayers = isEditing ? missingPlayers : nil
        missingPlayers = nil
        
        tableView.beginUpdates()
    }
    
    func controller(_ controller: NSFetchedResultsController<NSFetchRequestResult>, didChange sectionInfo: NSFetchedResultsSectionInfo, atSectionIndex sectionIndex: Int, for type: NSFetchedResultsChangeType) {
        guard !changeIsUserDriven else { return }

        switch type {
        case .insert:
            tableView.insertSections(IndexSet(integer: sectionIndex), with: .automatic)
        case .delete:
            tableView.deleteSections(IndexSet(integer: sectionIndex), with: .automatic)
        default:
            return
        }
    }
    
    func controller(_ controller: NSFetchedResultsController<NSFetchRequestResult>, didChange anObject: Any, at indexPath: IndexPath?, for type: NSFetchedResultsChangeType, newIndexPath: IndexPath?) {
        guard !changeIsUserDriven else { return }
    
        switch type {
        case .insert:
            let combatant = anObject as! Combatant
            if let player = combatant.player, let oldIndex = oldMissingPlayers?.index(of: player) {
                let oldIndexPath = IndexPath(row: oldIndex, section: 1)
                tableView.deleteRows(at: [ oldIndexPath ], with: .top)
                
                if combatant.initiative == nil {
                    selectIndexPath = newIndexPath
                }
            }
            
            tableView.insertRows(at: [newIndexPath!], with: .bottom)
        case .delete:
            // The combatant object will have already had its player relationship invalidated, so we cheat and store it in the cell.
            let cell = tableView.cellForRow(at: indexPath!) as! InitiativeCombatantCell
            if let player = cell.player, let newIndex = missingPlayers.index(of: player) {
                let newIndexPath = IndexPath(row: newIndex, section: 1)
                tableView.insertRows(at: [ newIndexPath ], with: .top)
            }
            
            tableView.deleteRows(at: [indexPath!], with: .bottom)
        case .move:
            // If the move is on the cell that's currently the first responder, it's probably as a result of the user editing; we don't want to pop the keyboard down and up, so just move the cell.
            if let cell = tableView.cellForRow(at: indexPath!) as? InitiativeCombatantCell, cell.initiativeTextField.isFirstResponder {
                tableView.moveRow(at: indexPath!, to: newIndexPath!)
            } else {
                tableView.deleteRows(at: [indexPath!], with: .automatic)
                tableView.insertRows(at: [newIndexPath!], with: .automatic)
            }
        case .update:
            if let cell = tableView.cellForRow(at: indexPath!) as? InitiativeCombatantCell {
                let combatant = anObject as! Combatant
                cell.combatant = combatant
            }
        }
    }
    
    func controllerDidChangeContent(_ controller: NSFetchedResultsController<NSFetchRequestResult>) {
        guard !changeIsUserDriven else {
            changeIsUserDriven = false
            return
        }

        tableView.endUpdates()
        
        if let indexPath = selectIndexPath, let cell = tableView.cellForRow(at: indexPath) as? InitiativeCombatantCell {
            cell.initiativeTextField.becomeFirstResponder()
            selectIndexPath = nil
        }

        validateEncounter()
    }

}

// MARK: -

class InitiativeCombatantCell : UITableViewCell, UITextFieldDelegate {
    
    @IBOutlet var nameLabel: UILabel!
    @IBOutlet var initiativeTextField: UITextField!
    
    var combatant: Combatant! {
        didSet {
            player = combatant.player

            if let monster = combatant.monster {
                nameLabel.text = monster.name
            } else if let player = combatant.player {
                nameLabel.text = player.name
            }
            
            initiativeTextField.text = combatant.initiative.map({ "\($0)" })
        }
    }
    var player: Player?
    
    @IBAction func textFieldEditingChanged(_ sender: UITextField) {
        if let text = sender.text, text != "" {
            if text != "-" {
                combatant.initiative = Int(text)!
            }
        } else {
            combatant.initiative = nil
        }
    }
    
    // MARK: UITextFieldDelegate
    
    func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {
        // A hyphen is valid at the start of an empty string, or where replacing the start of the string.
        if string.hasPrefix("-") {
            return range.location == 0
        }
        
        // Otherwise only digits are valid.1
        let validSet = CharacterSet.decimalDigits
        for character in string.unicodeScalars {
            if !validSet.contains(UnicodeScalar(character.value)!) {
                return false
            }
        }
        return true
    }

}

class InitiativeMissingPlayerCell : UITableViewCell {
    
    @IBOutlet var nameLabel: UILabel!

    var player: Player! {
        didSet {
            nameLabel.text = player.name
        }
    }

}
